import debug from "debug";
import { EventEmitter } from "events";
import * as Queue from "promise-queue";
import {
	CommandClassInfo,
	parseCommandClassInfo,
} from "../commands/commandClassInfo";
import { decodeParams } from "../commands/decode";
import { LengthType, ParameterType } from "../commands/spec";
import { convertFromJsonParams } from "../commands/specHelpers";
import { bufferToString, defer, Timer, toHex } from "../common/util";
import { Protocol } from "./protocol";
import { SerialAPICommand } from "./serialApiCommand";

const log = debug("zwave:serialapi");
const logData = log.extend("data");

export interface SerialAPICapabilities {
	applVersion: number;
	applRevision: number;
	manufacturerId: number;
	manufacturerProductType: number;
	manufacturerProductId: number;
	supportedFunctions: Set<SerialAPICommand>;
}

const SERIAL_API_CAPABILITIES_PARAMS = convertFromJsonParams([
	{ type: ParameterType.Integer, length: 1, name: "applVersion", help: "" },
	{ type: ParameterType.Integer, length: 1, name: "applRevision", help: "" },
	{
		type: ParameterType.Integer,
		length: 2,
		name: "manufacturerId",
		help: "",
	},
	{
		type: ParameterType.Integer,
		length: 2,
		name: "manufacturerProductType",
		help: "",
	},
	{
		type: ParameterType.Integer,
		length: 2,
		name: "manufacturerProductId",
		help: "",
	},
	{
		type: ParameterType.Bitmask,
		length: 256 / 8,
		name: "supportedFunctions",
		help: "",
	},
]);

export enum NodeCapabilityFlags {
	SlaveAPI = 0, // Otherwise ControllerAPI
	TimerSupported = 1,
	SecondaryController = 2, // Otherwise Primary
	IsSIS = 3,
}

export interface SerialAPIInitData {
	apiVersion: number;
	capabilities: Set<NodeCapabilityFlags>;
	nodes: Set<number>;
	chipType: number;
	chipVersion: number;
}

const SERIAL_API_INIT_DATA_PARAMS = convertFromJsonParams([
	{ type: ParameterType.Integer, length: 1, name: "apiVersion", help: "" },
	{ type: ParameterType.Bitmask, length: 1, name: "capabilities", help: "" },
	{
		type: ParameterType.Integer,
		length: 1,
		name: "nodesLength",
		help: "",
		isAutogenerated: true,
		lengthOf: { refs: ["nodes"] },
	},
	{
		type: ParameterType.Bitmask,
		name: "nodes",
		help: "",
		length: {
			lengthType: LengthType.ParameterReference,
			from: { ref: "nodesLength" },
		},
	},
	{
		type: ParameterType.Integer,
		length: 1,
		name: "chipType",
		help: "",
	},
	{
		type: ParameterType.Integer,
		length: 1,
		name: "chipVersion",
		help: "",
	},
]);

export interface HomeAndNodeId {
	/**
	 * 4-byte home ID of chip connected to serial API.
	 */
	homeId: number;

	/**
	 * Z-Wave Node ID [1..232] of chip connected to serial API.
	 */
	nodeId: number;
}

const ZW_MEMORY_GET_ID_PARAMS = convertFromJsonParams([
	{ type: ParameterType.Integer, length: 4, name: "homeId", help: "" },
	{ type: ParameterType.Integer, length: 1, name: "nodeId", help: "" },
]);

export enum ZwLibraryType {
	StaticController = 0x01,
	Controller = 0x02,
	EnhancedSlave = 0x03,
	Slave = 0x04,
	Installer = 0x05,
	RoutingSlave = 0x06,
	BridgeController = 0x07,
	Dut = 0x08,
	AvRemote = 0x0a,
	AvDevice = 0x0b,
}

export interface ZwVersionInfo {
	libraryVersion: string;
	libraryType: ZwLibraryType;
}

const ZW_GET_VERSION_PARAMS = convertFromJsonParams([
	{ type: ParameterType.Text, length: 12, name: "libraryVersion", help: "" },
	{ type: ParameterType.Integer, length: 1, name: "libraryType", help: "" },
]);

enum TxStatus {
	Ok = 0x00,
	NoAck = 0x01, // Node may be sleeping
	Fail = 0x02, // Network busy
	NotIdle = 0x03, // TODO
	NoRoute = 0x04, // TODO
}

enum ApplicationSlaveUpdateStatus {
	UPDATE_STATE_NODE_INFO_RECEIVED = 0x84,
}

export interface NodeInfo {
	nodeId: number;
	basicClass: number; // TODO BasicDeviceClassEnum
	genericClass: number; // TODO GenericDeviceClassEnum
	specificClass: number; // 'subclass' within GenericDeviceClassEnum
	commandClasses: CommandClassInfo;
}

const ZW_SEND_DATA_TIMEOUT = 65 * 1000; // See INS13954-Instruction-Z-Wave-500-Series-Appl-Programmers-Guide-v6_81_0x.pdf, fig 9

export enum DestinationType {
	Singlecast,
	Broadcast,
	Multicast,
}

export interface RxStatus {
	routedBusy: boolean; // A response route is locked by the application
	lowPower: boolean; // Received at low output power level
	destinationType: DestinationType; // Single/broadcast/multicast frame received
	explore: boolean; // Received an explore frame
	foreignFrame: boolean; // The received frame is not addressed to this node (Only valid in promiscuous mode)
	foreignHomeId: boolean; // The received frame is received from a foreign HomeID. Only Controllers in Smart Start AddNode mode can receive this status
}

export interface SerialApiEvent {
	rxStatus: RxStatus;
	sourceNode: number;
	data: Buffer;
}

export function rxStatusToString(rxStatus: RxStatus): string {
	return [
		DestinationType[rxStatus.destinationType],
		rxStatus.routedBusy ? ",routedBusy" : "",
		rxStatus.lowPower ? ",lowPower" : "",
		rxStatus.explore ? ",explore" : "",
		rxStatus.foreignFrame ? ",foreignFrame" : "",
		rxStatus.foreignHomeId ? ",foreignHomeId" : "",
	].join("");
}

function parseRxStatus(value: number): RxStatus {
	return {
		routedBusy: (value & 0b00000001) > 0,
		lowPower: (value & 0b00000010) > 0,
		destinationType: (value & 0b00001100) >> 2,
		explore: (value & 0b00011000) === 0b00010000,
		foreignFrame: (value & 0b01000000) > 0,
		foreignHomeId: (value & 0b10000000) > 0,
	};
}

export interface SerialApi {
	on(event: "event", listener: (event: SerialApiEvent) => void): this;
	on(event: "error", listener: (event: Error) => void): this;
	on(event: "close", listener: () => void): this;
}

export class SerialApi extends EventEmitter {
	private _protocol: Protocol;
	private _capabilities?: SerialAPICapabilities;
	private _initData?: SerialAPIInitData;
	private _homeAndNodeId?: HomeAndNodeId;
	private _callbackId: number = 0;
	private _requests = new Queue(1, Infinity);
	private _initialized = false;

	constructor(protocol: Protocol) {
		super();
		this._protocol = protocol;

		this._protocol.on("callback", (command, params) =>
			this._handleMessage(command, params)
		);
		this._protocol.on("error", (error) => this.emit("error", error));
		this._protocol.on("close", () => this.emit("close"));
	}

	/**
	 * Initialize SerialApi and return home id for connected controller.
	 *
	 * Afterwards, calls like `getNodes()`, `isController()` and `getHomeAndNodeId()`
	 * will be possible.
	 */
	public async init(): Promise<void> {
		await this.serialGetCapabilities(true);
		await this.zwGetVersion();
		await this.serialGetInitData(true);
		await this.zwMemoryGetId(true);
		this._initialized = true;
	}

	public isInitialized(): boolean {
		return this._initialized;
	}

	/**
	 * Determine whether connected Z-Wave chip is controller or slave.
	 *
	 * The instance needs to be initialized with `init()` first.
	 */
	public isController(): boolean {
		if (!this._initData) {
			throw new Error("SerialAPI not initialized yet");
		}
		return !this._initData.capabilities.has(NodeCapabilityFlags.SlaveAPI);
	}

	/**
	 * Get set of nodes as reported in last `serialGetInitData()` or `init()` call.
	 *
	 * To refresh the node list (e.g. after inclusion), call `serialGetInitData(true)`.
	 *
	 * The instance needs to be initialized with `init()` first.
	 */
	public getNodes(): Set<number> {
		if (!this._initData) {
			throw new Error("SerialAPI not initialized yet");
		}
		return this._initData.nodes;
	}

	/**
	 * Get currently assigned home and node ID, as reported by last
	 * call to `zwMemoryGetId()` or `init()`.
	 *
	 * To refresh the node list (e.g. after inclusion), call `serialGetInitData(true)`.
	 *
	 * The instance needs to be initialized with `init()` first.
	 */
	public getHomeAndNodeId(): HomeAndNodeId {
		if (!this._homeAndNodeId) {
			throw new Error("SerialAPI not initialized yet");
		}
		return this._homeAndNodeId;
	}

	/**
	 * Determine basic information about connected Z-Wave chip such
	 * as manufacturer/produce information, and which serial API functions are
	 * supported.
	 *
	 * Automatically called during init().
	 *
	 * @param forceRefresh (Optional) when false (default) returns cached info when available,
	 *                     when true, will always request fresh data from chip.
	 */
	public async serialGetCapabilities(
		forceRefresh: boolean = false
	): Promise<SerialAPICapabilities> {
		if (this._capabilities && !forceRefresh) {
			return this._capabilities;
		}
		this._capabilities = await this._requests.add(async () => {
			const response = await this._protocol.request(
				SerialAPICommand.SERIAL_API_GET_CAPABILITIES
			);
			return decodeParams<SerialAPICapabilities>(
				SERIAL_API_CAPABILITIES_PARAMS,
				response
			);
		});
		const caps = this._capabilities;
		log(
			`serialGetCapabilities:`,
			`applicationVersion=${caps.applVersion}.${
				caps.applRevision
			} manufacturerId=0x${toHex(
				caps.manufacturerId,
				4
			)} manufacturerProductType=0x${toHex(
				caps.manufacturerProductType,
				4
			)} manufacturerProductId=0x${toHex(caps.manufacturerProductId, 4)}`
		);
		log(
			`serialGetCapabilities supported functions: [${[
				...caps.supportedFunctions.values(),
			].map((func) => SerialAPICommand[func] ?? `0x${toHex(func)}`)}]`
		);
		return this._capabilities;
	}

	/**
	 * Determine role of connected chip (controller/slave etc), serial API version
	 * and list of nodes stored in RAM (for controllers).
	 *
	 * Automatically called during init().
	 *
	 * @param forceRefresh (Optional) when false (default) returns cached info when available,
	 *                     when true, will always request fresh data from chip.
	 */
	public async serialGetInitData(
		forceRefresh: boolean = false
	): Promise<SerialAPIInitData> {
		if (this._initData && !forceRefresh) {
			return this._initData;
		}
		this._initData = await this._requests.add(async () => {
			const response = await this._protocol.request(
				SerialAPICommand.SERIAL_API_GET_INIT_DATA
			);
			return decodeParams<SerialAPIInitData>(
				SERIAL_API_INIT_DATA_PARAMS,
				response
			);
		});
		const init = this._initData;
		const roleText = init.capabilities.has(NodeCapabilityFlags.SlaveAPI)
			? "slave"
			: init.capabilities.has(NodeCapabilityFlags.SecondaryController)
			? "secondaryController"
			: `primaryController isSIS=${init.capabilities.has(
					NodeCapabilityFlags.IsSIS
			  )}`;
		// Determine readable chip name (INS12350-Serial-API-Host-Appl.-Prg.-Guide - section 7.4)
		let chipName: string = "unknown";
		switch (init.chipType) {
			case 0x01:
				switch (init.chipVersion) {
					case 0x02:
						chipName = "ZW0102";
						break;
				}
				break;
			case 0x02:
				switch (init.chipVersion) {
					case 0x01:
						chipName = "ZW0201";
						break;
				}
				break;
			case 0x03:
				switch (init.chipVersion) {
					case 0x01:
						chipName = "ZW0301";
						break;
				}
				break;
			case 0x04:
				switch (init.chipVersion) {
					case 0x01:
						chipName = "ZM0401/ZM4102/SD3402";
						break;
				}
				break;
			case 0x05:
				switch (init.chipVersion) {
					case 0x00:
						chipName = "ZW050x";
						break;
				}
				break;
		}
		log(
			`serialGetInitData:`,
			`apiVersion=${init.apiVersion}`,
			`role=${roleText}`,
			`chipType=0x${init.chipType.toString(16)}`,
			`chipVersion=0x${init.chipVersion.toString(16)}`,
			`chipName=${chipName}`,
			`nodes=[${[...init.nodes.values()]}]`
		);
		return this._initData;
	}

	/**
	 * Retrieve Home ID and Node ID from connected serial chip.
	 *
	 * @param forceRefresh (Optional) when false (default) returns cached info when available,
	 *                     when true, will always request fresh data from chip.
	 */
	public async zwMemoryGetId(
		forceRefresh: boolean = false
	): Promise<HomeAndNodeId> {
		if (this._homeAndNodeId && !forceRefresh) {
			return this._homeAndNodeId;
		}
		this._homeAndNodeId = await this._requests.add(async () => {
			const response = await this._protocol.request(
				SerialAPICommand.ZW_MEMORY_GET_ID
			);
			return decodeParams<HomeAndNodeId>(
				ZW_MEMORY_GET_ID_PARAMS,
				response
			);
		});
		const homeAndId = this._homeAndNodeId;
		log(
			`zwMemoryGetId: homeId=0x${toHex(
				homeAndId.homeId,
				8
			)} nodeId=${homeAndId.nodeId.toString()}`
		);
		return this._homeAndNodeId;
	}

	/**
	 * Obtain Z-Wave chip's library version in human-readable form,
	 * and what type it is.
	 */
	public async zwGetVersion(): Promise<ZwVersionInfo> {
		const info = await this._requests.add(async () => {
			const response = await this._protocol.request(
				SerialAPICommand.ZW_GET_VERSION
			);
			return decodeParams<ZwVersionInfo>(ZW_GET_VERSION_PARAMS, response);
		});
		log(
			`zwGetVersion: libraryVersion="${
				info.libraryVersion
			}" libraryType=${ZwLibraryType[info.libraryType]}`
		);
		return info;
	}

	/**
	 * Send data to specified node or all nodes.
	 *
	 * @param nodeId Node ID to send data to, or 0xff to broadcast to all nodes
	 * @param data   Data to transmit
	 */
	public async zwSendData(nodeId: number, data: Buffer): Promise<boolean> {
		return this._requests.add(() => this._internalZwSendData(nodeId, data));
	}

	public async zwRequestNodeInfo(nodeId: number): Promise<NodeInfo> {
		return this._requests.add(async () => {
			log("zwRequestNodeInfo request", `node=${nodeId}`);
			const params = Buffer.from([nodeId]);

			const returnValue = await this._protocol.request(
				SerialAPICommand.ZW_REQUEST_NODE_INFO,
				params
			);
			// TODO dedup this logic
			if (returnValue.length !== 1) {
				log(
					"zwRequestNodeInfo",
					"failed: invalid response from serial chip"
				);
				throw new Error("invalid response from serial chip");
			}
			if (returnValue[0] === 0) {
				log(
					"zwRequestNodeInfo",
					"failed: command accepted by serial chip, but could not be delivered to network"
				);
				throw new Error(
					"command accepted by serial chip, but could not be delivered to network"
				);
			}

			// Reply expected, in the form of a ZW_SEND_DATA REQuest from serial chip to us
			const nodeInfo = await this._waitForREQ(
				ZW_SEND_DATA_TIMEOUT,
				(command: SerialAPICommand, params: Buffer) => {
					if (command !== SerialAPICommand.ZW_APPLICATION_UPDATE) {
						return;
					}
					if (params.length < 6) {
						return;
					}
					// INS13954-7 4.3.1.7 ApplicationSlaveUpdate
					const bStatus = params[0];
					const bNodeId = params[1];
					const bLen = params[2];
					const basicClass = params[3];
					const genericClass = params[4];
					const specificClass = params[5];
					const commandClassesRaw = params.slice(6);
					if (
						bStatus !==
						ApplicationSlaveUpdateStatus.UPDATE_STATE_NODE_INFO_RECEIVED
					) {
						return;
					}
					if (bNodeId !== nodeId) {
						return;
					}
					if (bLen !== params.length - 3 || bLen < 3) {
						return;
					}
					// NodeID | bLen | basic | generic | specific | commandclasses[ ]
					// 10       1a     04      11        01         5e 20 86 72 26 5a 59 85 73 98 7a 56 70 31 32 8e 60 75 71 27 22 ef 2b
					const commandClasses = parseCommandClassInfo(
						commandClassesRaw
					);
					return {
						nodeId,
						basicClass,
						genericClass,
						specificClass,
						commandClasses,
					};
				}
			);

			log("zwRequestNodeInfo", `result=`, nodeInfo);
			return nodeInfo;
		});
	}

	private _handleMessage(command: SerialAPICommand, params: Buffer): void {
		if (command === SerialAPICommand.APPLICATION_COMMAND_HANDLER) {
			const rxStatus = parseRxStatus(params[0]);
			const sourceNode = params[1];
			const cmdLength = params[2];
			const payload = params.slice(3, 3 + cmdLength);
			// const rxRSSIVal = params[params.length - 2];
			// const securityKey = params[params.length - 1];
			const event: SerialApiEvent = {
				rxStatus,
				sourceNode,
				data: payload,
			};
			log("emit event", event);
			process.nextTick(() => this.emit("event", event));
		}
	}

	private async _waitForREQ<T>(
		timeout: number,
		handler: (command: SerialAPICommand, params: Buffer) => T | undefined
	): Promise<T> {
		const waiter = defer<T>();
		const messageHandler = (command: SerialAPICommand, params: Buffer) => {
			try {
				const result = handler(command, params);
				if (result !== undefined) {
					waiter.resolve(result);
				}
			} catch (err) {
				waiter.reject(err);
			}
		};
		this._protocol.on("callback", messageHandler);
		const timer = new Timer(timeout, () =>
			waiter.reject(new Error("timeout"))
		);
		timer.start();
		let result;
		try {
			result = await waiter.promise;
		} finally {
			timer.stop();
			this._protocol.removeListener("callback", messageHandler);
		}
		return result;
	}

	private async _internalZwSendData(
		nodeId: number,
		data: Buffer
	): Promise<boolean> {
		// TODO INS13954 4.3.3.1 Prevent sending to virtual nodes inside the controller/bridge itself
		// TODO INS13954 4.3.3.1.5 Implement checks for minimum/maximum payload size:
		// Transmit option             non-secure  S0 secure
		// TRANSMIT_OPTION_EXPLORE     46 bytes    26 bytes
		// TRANSMIT_OPTION_AUTO_ROUTE  48 bytes    28 bytes
		// TRANSMIT_OPTION_NO_ROUTE    54 bytes    34 bytes
		// Payload must be minimum 1 byte

		// TODO INS13954 4.3.3.1.6 Exception recovery: If a timeout occurs, it is important to call ZW_SendDataAbortto stop the sending of the frame

		log(
			"zwSendData",
			`node=${nodeId}`,
			`payload=[${bufferToString(data)}]`
		);
		enum TransmitOptions {
			Ack = 0x01,
			AutoRoute = 0x04,
			Explore = 0x20, // reduce powerlevel by 6dB
		}

		const txOptions = TransmitOptions.Ack | TransmitOptions.AutoRoute;
		const funcId = this._getNextCallbackId();
		const params = Buffer.from([
			nodeId,
			data.length,
			...data,
			txOptions,
			funcId,
		]);

		const returnValue = await this._protocol.request(
			SerialAPICommand.ZW_SEND_DATA,
			params
		);
		if (returnValue.length !== 1) {
			log("zwSendData", "failed: invalid response from serial chip");
			throw new Error("invalid response from serial chip");
		}
		if (returnValue[0] === 0) {
			log(
				"zwSendData",
				"failed: command accepted by serial chip, but could not be delivered to network"
			);
			throw new Error(
				"command accepted by serial chip, but could not be delivered to network"
			);
		}

		// TODO: make sure that events cannot get lost (e.g. if promise resolve takes
		// a bit too long, and event was received before handler is attached)
		// Need a different architecture of this part for that, but don't know if the
		// current approach is what is needed anyway...

		// Reply expected, in the form of a ZW_SEND_DATA REQuest from controller to us
		const sendResult = await this._waitForREQ(
			ZW_SEND_DATA_TIMEOUT,
			(command: SerialAPICommand, params: Buffer) => {
				if (command !== SerialAPICommand.ZW_SEND_DATA) {
					return;
				}
				if (params.length < 2) {
					return;
				}
				// Spec: INS13954, 4.3.3.1.7
				if (params[0] !== funcId) {
					log("warn", `unexpected callback ID received, ignoring`);
					return;
				}
				const txStatus: TxStatus = params[1];
				if (txStatus !== 0) {
					// txStatus
					log(
						"warn",
						`error sending command (received code ${txStatus} (${TxStatus[txStatus]}))`
					);
					return false;
				}
				let transmitTime: number | undefined;
				if (params.length >= 4) {
					// DevKit 6.51+ added time measurement to response
					transmitTime = params.readUInt16BE(2) * 10; // in ms
				}
				log(
					`zwSendData ok${
						transmitTime !== undefined
							? `, transmitTime=${transmitTime}ms`
							: ""
					}`
				);
				return true;
			}
		);

		return sendResult;
	}

	private _getNextCallbackId(): number {
		this._callbackId++;
		if (this._callbackId === 0x100) {
			// Note: not 0, because that means we don't want feedback
			this._callbackId = 1;
		}
		return this._callbackId;
	}
}
